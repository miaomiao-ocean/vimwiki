 = 长连接管理调研 =
%title 大并发长连接管理调研报告

== TCP连接安全 ==
# 半连接安全: syn-cookie 
    * syn-cookie 
      - 用于处理半连接攻击, 可通过TCP系统设置配置打开 
# 全连接安全: tcp_defer_accept
    * tcp-keeplive 
      - 系统根据设置时间自动探测连接是否可用。间隔时间可通过TCP系统设置配置 
      - /proc/sys/net/ipv4/tcp_keepalive_time   : 多少时间发一次keepalive包 
      - /proc/sys/net/ipv4/tcp_keepalive_intvl  : 如果未收到回应，多少秒发一次keepalive包
      - /proc/sys/net/ipv4/tcp_keepalive_probes : 发送多少次keepalive等待包
    * tcp_defer_accept
      - 在服务端设置该配置，服务在接收到最后一次握手ack时，会自动丢掉，等待客户端发送连接后的请求数据,
        在收到请求数据后，才唤起accept处理。可有校的防止客户端只发连接的全连接攻击。
      - 设置了defer后，如果客户端未发送真实数据, 服务器处于 SYN_RECV状态，并由syn_ack定时器控制 
      - syn_ack重传次数由tcp_defer_accept设置的秒(内核转化为重试次数), TCP_SYNCNT 及/proc/sys/net/ipv4/tcp_synack_retries 决定
      - tcp_defer_accept计算次数算法: 测试所得, 与网上说的不太一样,
        设置的秒数是 发送次数达到两次发送syn_ack间隔时间. 发送间隔：
        0 3 6 12 24 48 96 120 。。。
        如果设置时间为1 则为1次(去除tcp_synack_retries影响), 
        如果设置时间为10 则为3次(去除tcp_synack_retries影响). 
    * 受权访问
      - 在建立连接好，客户端必须立即发送受权码给服务端，进行验证，验证不通过，则直接断开.
        为达到必须立即发送，见tcp_defer_accept处理
----
== TCP连接数突破 ==
# 受打开文件数限制
    * 当前shell: ulimit -n num 
    * 系统设置: vi /ect/security/limit.conf, 
      要使用limit.conf文件生效，必须要确保pam_limits.so 文件加入到启动文件中。
      查看/etc/pam.d/login文件，应该要有: session required /lib/security/pam_limits.so
# 受系统最大打开文件数限制
    * 一个系统最在找开文件数限制，是在系统启动时linux根据系统计算出来的，当然也可以自行修改,
      修改配置文件: /proc/sys/fs/file-max 
# 受系统内存大小限制
    * 一个连接建立后，需要保留空间用于 接收，发送数据。一般使用 4K * 2 的空间，因此一个连接需要占用8Kb内存。可以优化减少该值
    * 一个连接需要自己的处理对象，测试计算一个连接占用 0.085 Kb内存 
# 客户端端口限制(不影响服务端)    
    * 修改系统文件 /etc/sysctl.conf  增加： net.ipv4.ip_local_port_range = 1024 65535 
      执行sysctl -p 
----
== TCP系统设置 ==
[[http://www.perfgeeks.com/?p=18|TCP系统参数]]
----

== TCP连接测试 ==

内存: 16G /proc/pid/status 下的 VmRSS <br />
CPU: 四核，2.13GHZ Inte(R) Xeon(R)

| 测试参数   | >       | >        | >       | >      | 占用cpu | 占用mem(kb) |
| 总连接     | conn    | unconn   | recv    | send   | \/      | \/          |
|------------|---------|----------|---------|--------|---------|-------------|
| 10000      | >       | >        | >       | >      | 0       | 82968       |
| 21300      | >       | >        | >       | >      | 0       | 262948      |
| 50299      | >       | >        | >       | >      | 0       | 496760      |
| 99682      | >       | >        | >       | >      | 0       | 817172      |
| <50000     | 1000    | 0        | 0       | 0      | 3       | x           |
| <50000     | 5000    | 0        | 0       | 0      | 7       | x           |
| <50000     | 10000   | 0        | 0       | 0      | 8       | x           |
| <100000    | 10000   | 0        | 0       | 0      | 8       | x           |
| <50000     | 1000    | 1000     | 1000    | 0      | 5       | x           |
| <50000     | 5000    | 5000     | 5000    | 0      | 25      | x           |
| <100000    | 5000    | 5000     | 5000    | 0      | 25      | x           |
| <100000    | 10000   | 10000    | 10000   | 0      | 38      | x           |

----
== 连接管理服务设计 ==
=== 连接HOLD模块(A) ===
  - 连接HOLD模块只管理连接，及接收，发送连接数据，不处理业务逻辑。
  - 连接HOLD模块只接收长连接建立，不发起长连接。
  - 连接HOLD做为服务器，有以下几种客户端
    * 用户客户端 
    * 连接信息管理模块
    * 推送服务模块
    * 用户主动请求处理模块 * 
    * 地理位置判断模块 ** 
    * 全局消息触达模块
  - 连接HOLD工作规则   
    * 初始化监控端口(PA, PC), PA端口用于管理, PC用于客户端连接. 
    * 管理端口PA用于接收内部模块连接
    * 用户端口PC用于接收用户客户端连接 
    * 连接HOLD模块启动步骤:
      # 监听PA端口, 等待特定模块接入。必须接入模块: 连接信息管理模块
      # 连接信息管理模块连接成功，则监听PC端口。等待用户客户端接入
      # 等待其它模块的接入
    * 连接HOLD模块建立PC端口连接步骤    
      # 发起三次握手，建立连接 (此时不accept) 
      # 客户端发起authinfo信息, 鉴权并上报基本信息 
      # HOLD模块进行基础身份确认(包格式，密码)
      # 请求连接信息管理模块，登记连接信息并鉴权(业务类鉴权).
      # 接收连接
      # 如果连接信息管理不可达(连接断开了),关闭当前建立的连接。
      # 判断是否有可用 连接信息管理模块 连接。无则关闭 PC 端口监听, 不再允许建立新连接
      # 等带特定模块接入, 重复连接HOLD模块启动步骤.(注意不关闭已建立的连接)
    * 连接HOLD模块PC端口断开步骤 
      # 
=== 连接信息管理模块(B) ===
  统一管理所有连接信息，用于查询，定位某用户对应的连接所在服务, 句柄编号
=== 推送服务模块(B) ===  
  - 接收外部推送请求, 组装特定格式包，通过模块A,定位连接服务，句柄。发送推送数据.
  - 发送推送数据后，不等待返回结果，
# ----

